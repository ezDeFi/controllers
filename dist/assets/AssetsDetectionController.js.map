{"version":3,"file":"AssetsDetectionController.js","sourceRoot":"","sources":["../../src/assets/AssetsDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import contractMap from '@metamask/contract-metadata';\nimport BaseController, { BaseConfig, BaseState } from '../BaseController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport { safelyExecute, timeoutFetch, toChecksumHexAddress } from '../util';\nimport type {\n  AssetsController,\n  AssetsState,\n  CollectibleMetadata,\n} from './AssetsController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { Token } from './TokenRatesController';\n\nconst DEFAULT_INTERVAL = 180000;\nconst MAINNET = 'mainnet';\n\n/**\n * @type ApiCollectible\n *\n * Collectible object coming from OpenSea api\n *\n * @property token_id - The collectible identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this collectible\n * @property image_preview_url - URI of a smaller image associated with this collectible\n * @property image_thumbnail_url - URI of a thumbnail image associated with this collectible\n * @property image_original_url - URI of the original image associated with this collectible\n * @property animation_url - URI of a animation associated with this collectible\n * @property animation_original_url - URI of the original animation associated with this collectible\n * @property name - The collectible name\n * @property description - The collectible description\n * @property external_link - External link containing additional information\n * @property assetContract - The collectible contract information object\n * @property creator - The collectible owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiCollectible {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiCollectibleContract;\n  creator: ApiCollectibleCreator;\n  last_sale: ApiCollectibleLastSale | null;\n}\n\n/**\n * @type ApiCollectibleContract\n *\n * Collectible contract object coming from OpenSea api\n *\n * @property address - Address of the collectible contract\n * @property asset_contract_type - The collectible type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property name - The collectible contract name\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The collectible contract symbol\n * @property total_supply - Total supply of collectibles\n * @property description - The collectible contract description\n * @property external_link - External link containing additional information\n * @property image_url - URI of an image associated with this collectible contract\n */\nexport interface ApiCollectibleContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  name: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  image_url: string | null;\n}\n\n/**\n * @type ApiCollectibleLastSale\n *\n * Collectible sale object coming from OpenSea api\n *\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of collectible image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiCollectibleLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiCollectibleCreator\n *\n * Collectible creator object coming from OpenSea api\n *\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of collectible image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiCollectibleCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type AssetsConfig\n *\n * Assets controller configuration\n *\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface AssetsDetectionConfig extends BaseConfig {\n  interval: number;\n  networkType: NetworkType;\n  selectedAddress: string;\n  tokens: Token[];\n}\n\n/**\n * Controller that passively polls on a set interval for assets auto detection\n */\nexport class AssetsDetectionController extends BaseController<\n  AssetsDetectionConfig,\n  BaseState\n> {\n  private handle?: NodeJS.Timer;\n\n  private getOwnerCollectiblesApi(address: string) {\n    return `https://api.opensea.io/api/v1/assets?owner=${address}&limit=300`;\n  }\n\n  private async getOwnerCollectibles() {\n    const { selectedAddress } = this.config;\n    const api = this.getOwnerCollectiblesApi(selectedAddress);\n    let response: Response;\n    try {\n      const openSeaApiKey = this.getOpenSeaApiKey();\n      /* istanbul ignore if */\n      if (openSeaApiKey) {\n        response = await timeoutFetch(\n          api,\n          { headers: { 'X-API-KEY': openSeaApiKey } },\n          15000,\n        );\n      } else {\n        response = await timeoutFetch(api, {}, 15000);\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return [];\n    }\n    const collectiblesArray = await response.json();\n    const collectibles = collectiblesArray.assets;\n    return collectibles;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'AssetsDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private addTokens: AssetsController['addTokens'];\n\n  private addCollectible: AssetsController['addCollectible'];\n\n  private getAssetsState: () => AssetsState;\n\n  /**\n   * Creates a AssetsDetectionController instance\n   *\n   * @param options\n   * @param options.onAssetsStateChange - Allows subscribing to assets controller state changes\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address\n   * @param options.addTokens - Add a list of tokens\n   * @param options.addCollectible - Add a collectible\n   * @param options.getAssetsState - Gets the current state of the Assets controller\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(\n    {\n      onAssetsStateChange,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      getBalancesInSingleCall,\n      addTokens,\n      addCollectible,\n      getAssetsState,\n    }: {\n      onAssetsStateChange: (\n        listener: (assetsState: AssetsState) => void,\n      ) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addTokens: AssetsController['addTokens'];\n      addCollectible: AssetsController['addCollectible'];\n      getAssetsState: () => AssetsState;\n    },\n    config?: Partial<AssetsDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      networkType: 'mainnet',\n      selectedAddress: '',\n      tokens: [],\n    };\n    this.initialize();\n    this.getAssetsState = getAssetsState;\n    this.addTokens = addTokens;\n    onAssetsStateChange(({ tokens }) => {\n      this.configure({ tokens });\n    });\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const actualSelectedAddress = this.config.selectedAddress;\n      if (selectedAddress !== actualSelectedAddress) {\n        this.configure({ selectedAddress });\n        this.detectAssets();\n      }\n    });\n    onNetworkStateChange(({ provider }) => {\n      this.configure({ networkType: provider.type });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n    this.addCollectible = addCollectible;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval\n   *\n   * @param interval - Polling interval used to auto detect assets\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.detectAssets();\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not\n   *\n   * @returns - Whether current network is mainnet\n   */\n  isMainnet() {\n    if (this.config.networkType !== MAINNET || this.disabled) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Detect assets owned by current account on mainnet\n   */\n  async detectAssets() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    this.detectTokens();\n    this.detectCollectibles();\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet\n   */\n  async detectTokens() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    const tokensAddresses = this.config.tokens.map(\n      /* istanbul ignore next*/ (token) => token.address,\n    );\n    const tokensToDetect: string[] = [];\n    for (const address in contractMap) {\n      const contract = contractMap[address];\n      if (contract.erc20 && !tokensAddresses.includes(address)) {\n        tokensToDetect.push(address);\n      }\n    }\n\n    const { selectedAddress } = this.config;\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n    await safelyExecute(async () => {\n      const balances = await this.getBalancesInSingleCall(\n        selectedAddress,\n        tokensToDetect,\n      );\n      const tokensToAdd = [];\n      for (const tokenAddress in balances) {\n        let ignored;\n        /* istanbul ignore else */\n        const { ignoredTokens } = this.getAssetsState();\n        if (ignoredTokens.length) {\n          ignored = ignoredTokens.find(\n            (token) => token.address === toChecksumHexAddress(tokenAddress),\n          );\n        }\n        if (!ignored) {\n          tokensToAdd.push({\n            address: tokenAddress,\n            decimals: contractMap[tokenAddress].decimals,\n            symbol: contractMap[tokenAddress].symbol,\n          });\n        }\n      }\n      if (tokensToAdd.length) {\n        await this.addTokens(tokensToAdd);\n      }\n    });\n  }\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet\n   * adding new collectibles and removing not owned collectibles\n   */\n  async detectCollectibles() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    const requestedSelectedAddress = this.config.selectedAddress;\n\n    /* istanbul ignore else */\n    if (!requestedSelectedAddress) {\n      return;\n    }\n    await safelyExecute(async () => {\n      const apiCollectibles = await this.getOwnerCollectibles();\n      const addCollectiblesPromises = apiCollectibles.map(\n        async (collectible: ApiCollectible) => {\n          const {\n            token_id,\n            num_sales,\n            background_color,\n            image_url,\n            image_preview_url,\n            image_thumbnail_url,\n            image_original_url,\n            animation_url,\n            animation_original_url,\n            name,\n            description,\n            external_link,\n            creator,\n            asset_contract: { address },\n            last_sale,\n          } = collectible;\n\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredCollectibles } = this.getAssetsState();\n          if (ignoredCollectibles.length) {\n            ignored = ignoredCollectibles.find((c) => {\n              /* istanbul ignore next */\n              return (\n                c.address === toChecksumHexAddress(address) &&\n                c.tokenId === Number(token_id)\n              );\n            });\n          }\n          /* istanbul ignore else */\n          if (\n            !ignored &&\n            requestedSelectedAddress === this.config.selectedAddress\n          ) {\n            /* istanbul ignore next */\n            const collectibleMetadata: CollectibleMetadata = Object.assign(\n              {},\n              { name },\n              creator && { creator },\n              description && { description },\n              image_url && { image: image_url },\n              num_sales && { numberOfSales: num_sales },\n              background_color && { backgroundColor: background_color },\n              image_preview_url && { imagePreview: image_preview_url },\n              image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n              image_original_url && { imageOriginal: image_original_url },\n              animation_url && { animation: animation_url },\n              animation_original_url && {\n                animationOriginal: animation_original_url,\n              },\n              external_link && { externalLink: external_link },\n              last_sale && { lastSale: last_sale },\n            );\n            await this.addCollectible(\n              address,\n              Number(token_id),\n              collectibleMetadata,\n              true,\n            );\n          }\n        },\n      );\n      await Promise.all(addCollectiblesPromises);\n    });\n  }\n}\n\nexport default AssetsDetectionController;\n"]}